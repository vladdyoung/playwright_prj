# Содержание
### Зачем нужен класс MainPage
### Зачем нужен класс BasePage
### Когда ресурс доступен только после авторизации и когда можно пользоваться ресурсом без авторизации.
### Если можно пользоваться приложением без авторизации, метод для работы со страницей авторизации не используем.
### Метод open находится в BasePage, а не в MainPage, т.к. это метод для открытия какой-либо страницы. Т.к. все pages
### allure-results в корень
### Логирование с Loguru
### Новый проект
### Защитить данные с помощью .env
### Защитить данные с помощью Vault
### Описание работы Session


### Зачем нужен класс MainPage.

Он необходим для взаимодействия с классом BasePage. Наследуясь от BasePage в MainPage мы в базовом классе имеем
возможность работать с инициализатором __init__ BasePage.
---------------------------------------------------------------------------------------------------------

### Зачем нужен класс BasePage
BasePage используется как основа. В ней находится инициализатор, который принимает браузер и URL. Наследуясь от BasePage,
можем использовать браузер и URL для работы в любой страницы (в любом классе например MainPage или LoginPage)

---------------------------------------------------------------------------------------------------------
### Когда ресурс доступен только после авторизации и когда можно пользоваться ресурсом без авторизации.
Если начинаем с авторизации, тогда можно реализовать отдельный метод, где начинаем со страницы авторизации и, соответственно,
с метода открытия страницы авторизации, а затем загружаем основную страницу приложения.

Пример:

Метод для работы со страницей авторизации
@allure.step('Открыть главную страницу')
def open(cls, url: str, user: WorkplaceUser):
    browser.open(url)
    login_page = LoginPage()
    login_page.wait_loading()
    if browser.element('//h3 | //h2').get(query.text) == 'Авторизация':
        login_page.login(user=user)
    return cls()

Метод для работы с главной страницей
def open_order(session: Session, order: dict, role: str):
    page = MainPage.open(session.workplace, session.workplace_users.get(role))
    page = page.open_menu_item(item='Список заявок', page_class=PAGE_BY_NAME.get('Список заявок'))
    page.open_order_by_number(number=crm_order_id)

    with allure.step(f'Заявка {crm_order_id} открыта'):
        page.get_element(page.TITLE).with_(timeout=10).should(have.text(crm_order_id))
    return page

 Тест
 def test_overlight_full_agreed(session: Session, order, order_builder, title):
    page = order_steps.open_order(session=session, order=order.json, role=WorkplaceRoles.CREDIT_ANALYST)
---------------------------------------------------------------------------------------------------------

### Если можно пользоваться приложением без авторизации, метод для работы со страницей авторизации не используем.

Пример:

Тест
    def test_reg_new_user(self, page, base_url):
        main_page = MainPage(page=page, url=base_url)
        main_page.open()
---------------------------------------------------------------------------------------------------------

### Метод open находится в BasePage, а не в MainPage, т.к. это метод для открытия какой-либо страницы. Т.к. все pages
наследуются от базовой страницы, метод открытия должен находится именно в базовом классе. Если он будет находиться в
MainPage например, наследоваться нужно будет от MainPage, а это не правильно
---------------------------------------------------------------------------------------------------------

### allure-results в корень:

addopts = --alluredir ../../allure-results
---------------------------------------------------------------------------------------------------------
### Allure

@allure.step('Проверить смену языка')  # шаг теста
with allure.step('Проверка смены языка'):  # подшаг внутри теста
---------------------------------------------------------------------------------------------------------

### Логирование с Loguru:

Фикстура в conftest.py, которая модернизирует объект logger. Добавляет в него нужный путь до файла с логом, формат,
уровень, размер лог-файла, сжатие заполненного лог-файла в формат zip.

@pytest.fixture(scope="session", autouse=True)
def logger_prj():
    """ Фикстура для логирования с помощью LOGURU """

    logger.add('../../logs/log.log', format='{time} {level} {message}', level='ERROR', rotation='100 KB',
               compression='zip')

Вместе с фикстурой нужно использовать декоратор @logger.catch(reraise=True).
Параметр reraise=True нужен для того, чтобы тест отловил ошибку и закончился с результатом Failed. Иначе тест отловит
ошибку, но закончится с результатом Passed и можно пропустить ошибку.
---------------------------------------------------------------------------------------------------------

### Новый проект

1) conftest.py
2) config.py
3) где храним пароли? .env и т.д.
4) pages
    4.1) Базовая страница (класс)
    4.2) Главная страница (класс)
    4.3) Другие страницы приложения (классы)
5) tests
6) fixtures свои фикстуры. Регистрируем в conftest.py
7) Выбираем фреймворк для взаимодействия с браузером (Selenium, Selene, Playwright)
8) Настраиваем pytest
9) Прикручиваем allure. Настраиваем дирректорию для хранения отчетов
10) Прикручиваем логирование (logging, loguru). Настраиваем дирректорию для хранения логов
---------------------------------------------------------------------------------------------------------

### Защитить данные с помощью .env:
Создать файл .env
Положить туда данные в виде переменных EMAIL=example
В нужном модуле (login_page.py) импортировать стандартные библиотеки: import os import dotenv
В классе (например LoginPage) создать dotenv.load_dotenv()  # для работы с переменными из .env
Ниже создать обратиться к переменным из .env: EMAIL = os.environ['EMAIL'] PASS = os.environ['PASSWORD']
---------------------------------------------------------------------------------------------------------

### Защитить данные с помощью Vault:
Первый способ.
Установка с помощью Docker.
1) PowerShell: docker run -d --name=dev-vault -e 'VAULT_DEV_ROOT_TOKEN_ID=myroot' -p 8200:8200 vault:1.13.3
(можно любую версию, но latest не грузится)
2) https://localhost:8200 Token: myroot

Второй способ.
Установка c помощью vault.exe (Не использовать, т.к. нужно каждый раз держать открытой cmd и не сохраняет секреты):
Скачать Vault (https://developer.hashicorp.com/vault/install?product_intent=vault)
В PowerShell или cmd зайти в директорию со скаченным файлом и выполнить команду ./vault.exe server -dev
Найти локальный адрес с портом 8200
Скопировать токен для входа в Vault
Зайти в Vault по локальному адресу

Создание архитектуры в проекте:
Создать модуль vault_helper.py
Создать модуль session.py с классом Session
Создать фикстуру в conftest.py для инициализации Session
Добавить в conftest.py   parser.addoption("--vault_token")
---------------------------------------------------------------------------------------------------------

### Описание работы Session
Простыми словами: клиент в vault_helper.py с помощью get_configuration забирает из вольта данные, парсит их с
помощью parse_config_string и складывает в Session в виде переменных к сервисам (self.auth_data = self.vault_config['AUTH_DATA'])

Session необходим, чтобы хранить в нем переменные из вольта.
Фикстура session необходима, чтобы инициализировать и использовать переменные из Session.

В модуле vault_helper.py хранятся методы для работы с Vault:
    1)  get_configuration # соединяется с vault используя токен и адрес, где развернут vault;
        токен для vault прописывать через параметр при запуске тестов --vault_token;
        его мы получаем из командной строки по средствам pytest-хука pytest_addoption в conftest.py;

    2) parse_config_string парсит данные из переменной vault в словарь (описание в коде)

Модуль session.py служит как хранилище переменных, которые получаем из vault. Представляет из себя class Session,
в инициализаторе которого находятся:
    1) переменная с методом для получения токена из командной строки (self.vault_token = request.config.getoption("--vault_token"));
    2) переменная - путь до секретов в вольт
    3) все переменные из вольта в одной переменной self.vault_config
    4) отдельно переменные из вольта для разных сервисов (например переменная с email/pass для регистрации self.auth_data = self.vault_config['AUTH_DATA'])

conftest.py
Содержит:
    1) фикстуру для инициализации Session
    2) хук для добавления переменной --vault_token в cmd

В class BasePage проинициализировать session, чтобы session можно было использовать во всех PageObject:
    def __init__(self, page: Page, session: Session, url):
        self.page = page
        self.url = url
        self.session = session

В LoginPage можно обращаться к значениям переменной, которую получили из вольт через session (self.session.auth_data['EMAIL'])

При инициализации какой либо страницы из PageObject, учитывать фикстуру session:
    def test_reg_new_user(self, page, session, base_url):
        page = LoginPage(page=page, session=session, url=base_url)

